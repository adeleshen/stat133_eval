---
title: "warmup05-adele-shen"
author: "Ruiwen (Adele) Shen"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = TRUE)
```

```{r}
# writing simple functions
# documenting functions with Roxygen comments
# using conditionals

# @title
# @description
# @param
# @return
```

```{r}
library(ggplot2)
```

# 1) Gaussian Function
```{r}
#' @title Gaussian function
#' @description Computes probability density of normal distribution
#' @param x values in data set (numeric)
#' @param m mean of normal (numeric)
#' @param s standard deviation of normal (numeric)
#' @return computed probability density

gaussian = function(x = 0, m = 0, s = 1) {
  if (s <= 0) {
    stop("s must be greater than zero")
  }
  pdf = (1/(s*sqrt(2*pi)))*exp(-0.5*((x-m)/s)^2)
  return(pdf)
}

# test set 1
gaussian(x = 0, m = 0, s = 1)
gaussian(x = 1, m = 0, s = 2)
# test set 2
gaussian(x = 1, m = 0, s = 0)
gaussian(x = 1, m = 0, s = -1)
```

```{r}
x = seq(-4.5, 4.5, by = 0.1)
y = gaussian(x = x, m = 0, s = 2)
plot(x, y, las = 1, type = "l", lwd = 2)
```

```{r}
x = seq(-5, 5, by = 0.1)
plot = ggplot() +
  geom_line(aes(x, gaussian(x, 0, sqrt(0.2))), size = 1, color = "#000080") +
  geom_line(aes(x, gaussian(x, 0, sqrt(1))), size = 1, colour = "#8b0000") +
  geom_line(aes(x, gaussian(x, 0, sqrt(5))), size = 1, colour = "#CCCC00") +
  geom_line(aes(x, gaussian(x, -2, sqrt(0.5))), size = 1, colour = "#006400") + 
  geom_smooth() +
  theme_bw() +
  xlab(expression(chi)) +
  ylab(expression(paste(phi[mu][","][sigma^2],"(",chi,")")))
plot
```
 

# 2) Descriptive Statistics

```{r}
#' @title Descriptive Statistics
#' @description Computes summary descriptive statistics: min, q1, median
#' mean, q3, max, range, iqr, and sd
#' @param x vector to be described (numeric)
#' @param na.rm determine whether to remove missing values or not (logical)
#' @return named vector of descriptive statistics
descriptive <- function(x, na.rm = FALSE) {
  if (!is.numeric(x)) {
    stop('input x is not numeric')
}
  c(
    "min" = min(x, na.rm = na.rm),
    "q1" = quantile(x, probs = 0.25, na.rm = na.rm),
    "median" = median(x, na.rm = na.rm),
    "mean" = mean(x, na.rm = na.rm),
    "q3" = quantile(x, probs = 0.75, na.rm = na.rm),
    "max" = max(x, na.rm = na.rm),
    "range" = max(x, na.rm = na.rm) - min(x, na.rm = na.rm),
    "iqr" = IQR(x, na.rm = na.rm),
    "sd" = sd(x, na.rm = na.rm)
)
}
```

```{r}
# input vectors
set.seed(100)
x <- rnorm(100)
y <- x
y[sample(1:100, size = 10)] <- NA
# test set 1
descriptive(x)
descriptive(y)
descriptive(y, na.rm = TRUE)
descriptive(letters)
# test set 2
a <- descriptive(x)
class(a)
length(a)
names(a)
```

# 3) Minkowski Distance
```{r}
#' @title Minkowski distance
#' @description Computes minkowski distance between two points
#' @param x vector (numeric)
#' @param y vector (numeric)
#' @param p value (numeric) or character string "max"
#' @return minkowski distance
minkowski <- function(x, y, p = 1) {
  if (length(x) != length(y)) {
    stop('x and y have different lengths')
    }
  if (is.numeric(p)) {
    if (p < 1) {
      stop('p cannot be less than 1')
      }
    mink = (abs(x - y))^p
    return(sum(terms)^(1/p))
    } else {
      if (p != 'max') {
        stop('invalid character value for p')
        }
      mink = abs(x - y)
      return(max(mink))
}
}

# some points
point1 <- c(0, 0)
point2 <- c(1, 1)
point3 <- sqrt(c(2, 2))
point4 <- c(0, 1)
point5 <- c(1, 1, 1)
# test set 1
minkowski(point1, point2, p = 1)
minkowski(point1, point3, p = 2)
minkowski(point1, point2, p = 'max')
# test set 2
minkowski(point4, point5, p = 1)
minkowski(point1, point2, p = 0.5)
minkowski(point1, point2, p = 'min')
```













