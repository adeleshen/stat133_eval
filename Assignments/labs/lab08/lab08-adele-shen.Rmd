---
title: "lab08-adele-shen"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# vectorized operations are calculations that are applied to all the elements in a vector (element-wise operations)
# instead, think about control-flow structures, which are essential in any programming activity
```

```{r}
vec <- c(3, 1, 4)

for (j in 1:3) {
  print(vec[j] + 1)
}
```

```{r}
vec <- c(3, 1, 4)  # Change this value!
vec2 <- rep(0, length(vec))  # "empty" of zeros vector to be filled in the loop

for (i in c()) {# Replace c() with an appropriate sequence.
  # Fill in.
}
```

# Summation Series
```{r}
sum_series_2 = function(n) {
  sum = 0
  if (n < 1) {
    stop()
  }
  if (n >= 1) {
    for (k in 0:n) {
      sum = sum + 1/2^k
    }
  }
  return(sum)
}
```

```{r}
sum_series_2(n = 2)
sum_series_2(n = 10)
sum_series_2(n = 200)

#Yes, series converges to 2.
```

```{r}
sum_series_9 = function(n) {
  sum = 0
  if (n < 1) {
    stop()
  }
  if (n >= 1) {
    for (k in 0:n) {
      sum = sum + 1/9^k
    }
  }
  return(sum)
}
```

# * Arithmetic Series
```{r}
arithmetic = function(a_1 = 3, d = 3, n = 2) {
  sum = rep(0, n)
  for (i in 1:n) {
    a_i = a_1 + (i-1)*d
    sum[i] = a_i
  }
  return(sum)  
}

arithmetic(n = 2)
arithmetic(n = 10)
arithmetic(n = 200)
```


# Geometric Series

```{r}
g_series = function(a1 = 3, r = 0.5, n = 2) {
  sum = 0
  for (i in 1:n) {
    a_i = a1 * r^(i-1)
    sum = sum + a_i
  }
  return(sum)
}

g_series()
```

# Sine Approximation
```{r}
sinx = function(x = 1, terms = 5) {
  sum = 0
  for (i in 1:terms) {
    sign = rep(c(1, -1), terms)
    exp = seq(1, terms*2, by = 2)
    term = x * sign[i] / factorial(exp[i])
    sum = sum + term 
  }
  return(sum)
}
```

# Sin Sequence
```{r}
sinx = function(x = 1, terms = 5) {
  sum = rep(0, terms)
  for (i in 1:terms) {
    sign = rep(c(1, -1), terms)
    exp = seq(1, terms*2, by = 2)
    term = x * sign[i] / factorial(exp[i])
    sum[i] = term
  }
  return(sum)
}
```

#Matrix

```{r}
set.seed(123)
A <- matrix(rnorm(12), nrow = 4, ncol = 3)
A
```


```{r}
# empty matrix B
B <- matrix(NA, nrow = 4, ncol = 3)

# for loop to get matrix B
for (i in 1:nrow(A)) {
  for (j in 1:ncol(A)) {
    if (A[i,j] < 0) {
      B[i,j] = (A[i,j])^2
    } 
    if (A[i,j] > 0) {
      B[i,j] = sqrt(A[i,j])
    }
  }
}

B
```

# Reduce
```{r}
reduce = function(x) {
  while (x %% 2 == 0) { # Continue the loop as long as val_while is even.
  x = x / 2
  }
return(x)
}
```

# Your Turn*: Average
```{r}
# for
x = 1:100

sum = 0
for (i in 1:length(x)) {
  sum = sum + x[i]
}
ave = sum / length(x)
ave
```

```{r}
# while
x = 1:100
sum = 0
i = 1

while (i <= length(x)) {
  sum = sum + x[i]
  i = i + 1
}
ave = sum / length(x)
ave
```

```{r}
# repeat
x = 1:100
sum = 0
i = 1

repeat {
  sum = sum + x[i]
  i = i +1
  if (i > length(x)) break
}
  
ave = sum / length(x)
ave
```


# Standard Deviation
```{r}
# for
x = 1:100
error = 0
for (i in 1:length(x)) {
  error = error + (x[i] - ave)^2
}
sd = sqrt(error / (length(x) - 1))
sd

```

```{r}
# while
x = 1:100
error = 0
i = 1

while (i <= length(x)) {
  error = error + (x[i] - ave)^2
  i = i + 1
}
sd = sqrt(error / (length(x) - 1))
sd
```

```{r}
# repeat
x = 1:100
error = 0
i = 1
repeat {
  error = error + (x[i] - ave)^2
  i = i + 1
  if (i > length(x)) break
}
sd = sqrt(error / (length(x) - 1))
sd
```

# Geometric Mean
```{r}
# for
x = 1:50
mean = 1
for (i in 1:length(x)) {
  mean = mean*x[i]
}
geom_mean = mean^(1/length(x))
geom_mean
```

# Distance Matrix of Letters

```{r}
# random distance matrix
num_letters <- length(LETTERS)
set.seed(123)
values <- sample.int(num_letters) 
distances <- values %*% t(values)
diag(distances) <- 0
dimnames(distances) <- list(LETTERS, LETTERS)
```

```{r}
get_dist = function(distances = distances, ltrs = c('E', 'D', 'A')) {
  dist = 0
  if (ltrs[1:length(ltrs)] %in% LETTERS == FALSE) {
    stop("Unrecognized character")
  } else for (i in 1: (length(ltrs)-1)) {
    dist = dist + distances[ltrs[i], ltrs[i+1]]
  }
  return(dist)
}

vec <- c('E', 'D', 'A')
get_dist(distances, vec)
```

```{r}
cal <- c('C', 'A', 'L')
stats <- c('S', 'T', 'A', 'T', 'S')
oski <- c('O', 'S', 'K', 'I')
zzz <- rep('Z', 3)
lets <- LETTERS
first = c('A', 'D', 'E', 'L', 'E')
last = c('S', 'H', 'E', 'N')

strings <- list(
  cal = cal,
  stats = stats,
  oski = oski,
  zzz = zzz,
  lets = lets,
  first = first,
  last = last
)

get_dist(distances, strings[[7]])
```

```{r}
string_dists = rep(0, length(strings))
for (i in 1:length(strings)) {
  string_dists[i] = get_dist(distances, strings[[i]])
}
string_dists
```


